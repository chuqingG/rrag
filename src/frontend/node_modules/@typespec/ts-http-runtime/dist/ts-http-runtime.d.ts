/// <reference types="node" />

/**
 * Represents a function that returns a promise that can be aborted.
 */
export declare type AbortablePromiseBuilder<T> = (abortOptions: {
    abortSignal?: AbortSignalLike;
}) => Promise<T>;

/**
 * This error is thrown when an asynchronous operation has been aborted.
 * Check for this error by testing the `name` that the name property of the
 * error matches `"AbortError"`.
 *
 * @example
 * ```ts
 * const controller = new AbortController();
 * controller.abort();
 * try {
 *   doAsyncWork(controller.signal)
 * } catch (e) {
 *   if (e.name === 'AbortError') {
 *     // handle abort error here.
 *   }
 * }
 * ```
 */
export declare class AbortError extends Error {
    constructor(message?: string);
}

/**
 * Options related to abort controller.
 */
export declare interface AbortOptions {
    /**
     * The abortSignal associated with containing operation.
     */
    abortSignal?: AbortSignalLike;
    /**
     * The abort error message associated with containing operation.
     */
    abortErrorMsg?: string;
}

/**
 * Allows the request to be aborted upon firing of the "abort" event.
 * Compatible with the browser built-in AbortSignal and common polyfills.
 */
export declare interface AbortSignalLike {
    /**
     * Indicates if the signal has already been aborted.
     */
    readonly aborted: boolean;
    /**
     * Add new "abort" event listener, only support "abort" event.
     */
    addEventListener(type: "abort", listener: (this: AbortSignalLike, ev: any) => any, options?: any): void;
    /**
     * Remove "abort" event listener, only support "abort" event.
     */
    removeEventListener(type: "abort", listener: (this: AbortSignalLike, ev: any) => any, options?: any): void;
}

/**
 * Represents an access token with an expiration time.
 */
export declare interface AccessToken {
    /**
     * The access token returned by the authentication service.
     */
    token: string;
    /**
     * The access token's expiration timestamp in milliseconds, UNIX epoch time.
     */
    expiresOnTimestamp: number;
}

/**
 * Adds a credential policy to the pipeline if a credential is provided. If none is provided, no policy is added.
 */
export declare function addCredentialPipelinePolicy(pipeline: Pipeline, endpoint: string, options?: AddCredentialPipelinePolicyOptions): void;

/**
 * Optional parameters for adding a credential policy to the pipeline.
 */
export declare interface AddCredentialPipelinePolicyOptions {
    /**
     * Options related to the client.
     */
    clientOptions?: ClientOptions;
    /**
     * The credential to use.
     */
    credential?: TokenCredential | KeyCredential;
}

/**
 * Used to configure additional policies added to the pipeline at construction.
 */
export declare interface AdditionalPolicyConfig {
    /**
     * A policy to be added.
     */
    policy: PipelinePolicy;
    /**
     * Determines if this policy be applied before or after retry logic.
     * Only use `perRetry` if you need to modify the request again
     * each time the operation is retried due to retryable service
     * issues.
     */
    position: "perCall" | "perRetry";
}

/**
 * Options when adding a policy to the pipeline.
 * Used to express dependencies on other policies.
 */
export declare interface AddPipelineOptions {
    /**
     * Policies that this policy must come before.
     */
    beforePolicies?: string[];
    /**
     * Policies that this policy must come after.
     */
    afterPolicies?: string[];
    /**
     * The phase that this policy must come after.
     */
    afterPhase?: PipelinePhase;
    /**
     * The phase this policy belongs to.
     */
    phase?: PipelinePhase;
}

/**
 * An interface compatible with NodeJS's `http.Agent`.
 * We want to avoid publicly re-exporting the actual interface,
 * since it might vary across runtime versions.
 */
export declare interface Agent {
    /**
     * Destroy any sockets that are currently in use by the agent.
     */
    destroy(): void;
    /**
     * For agents with keepAlive enabled, this sets the maximum number of sockets that will be left open in the free state.
     */
    maxFreeSockets: number;
    /**
     * Determines how many concurrent sockets the agent can have open per origin.
     */
    maxSockets: number;
    /**
     * An object which contains queues of requests that have not yet been assigned to sockets.
     */
    requests: unknown;
    /**
     * An object which contains arrays of sockets currently in use by the agent.
     */
    sockets: unknown;
}

/**
 * Options sent to the authorizeRequestOnChallenge callback
 */
export declare interface AuthorizeRequestOnChallengeOptions {
    /**
     * The scopes for which the bearer token applies.
     */
    scopes: string[];
    /**
     * Function that retrieves either a cached access token or a new access token.
     */
    getAccessToken: (scopes: string[], options: GetTokenOptions) => Promise<AccessToken | null>;
    /**
     * Request that the policy is trying to fulfill.
     */
    request: PipelineRequest;
    /**
     * Response containing the challenge.
     */
    response: PipelineResponse;
    /**
     * A logger, if one was sent through the HTTP pipeline.
     */
    logger?: TypeSpecRuntimeLogger;
}

/**
 * Options sent to the authorizeRequest callback
 */
export declare interface AuthorizeRequestOptions {
    /**
     * The scopes for which the bearer token applies.
     */
    scopes: string[];
    /**
     * Function that retrieves either a cached access token or a new access token.
     */
    getAccessToken: (scopes: string[], options: GetTokenOptions) => Promise<AccessToken | null>;
    /**
     * Request that the policy is trying to fulfill.
     */
    request: PipelineRequest;
    /**
     * A logger, if one was sent through the HTTP pipeline.
     */
    logger?: TypeSpecRuntimeLogger;
}

/**
 * A policy that can request a token from a TokenCredential implementation and
 * then apply it to the Authorization header of a request as a Bearer token.
 */
export declare function bearerTokenAuthenticationPolicy(options: BearerTokenAuthenticationPolicyOptions): PipelinePolicy;

/**
 * The programmatic identifier of the bearerTokenAuthenticationPolicy.
 */
export declare const bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";

/**
 * Options to configure the bearerTokenAuthenticationPolicy
 */
export declare interface BearerTokenAuthenticationPolicyOptions {
    /**
     * The TokenCredential implementation that can supply the bearer token.
     */
    credential?: TokenCredential;
    /**
     * The scopes for which the bearer token applies.
     */
    scopes: string | string[];
    /**
     * Allows for the processing of [Continuous Access Evaluation](https://docs.microsoft.com/azure/active-directory/conditional-access/concept-continuous-access-evaluation) challenges.
     * If provided, it must contain at least the `authorizeRequestOnChallenge` method.
     * If provided, after a request is sent, if it has a challenge, it can be processed to re-send the original request with the relevant challenge information.
     */
    challengeCallbacks?: ChallengeCallbacks;
    /**
     * A logger can be sent for debugging purposes.
     */
    logger?: TypeSpecRuntimeLogger;
}

/**
 * A part of the request body in a multipart request.
 */
export declare interface BodyPart {
    /**
     * The headers for this part of the multipart request.
     */
    headers: HttpHeaders;
    /**
     * The body of this part of the multipart request.
     */
    body: ((() => ReadableStream<Uint8Array>) | (() => NodeJS.ReadableStream)) | ReadableStream<Uint8Array> | NodeJS.ReadableStream | Uint8Array | Blob;
}

/**
 * promise.race() wrapper that aborts rest of promises as soon as the first promise settles.
 */
export declare function cancelablePromiseRace<T extends unknown[]>(abortablePromiseBuilders: AbortablePromiseBuilder<T[number]>[], options?: {
    abortSignal?: AbortSignalLike;
}): Promise<T[number]>;

/**
 * Options to override the processing of [Continuous Access Evaluation](https://docs.microsoft.com/azure/active-directory/conditional-access/concept-continuous-access-evaluation) challenges.
 */
export declare interface ChallengeCallbacks {
    /**
     * Allows for the authorization of the main request of this policy before it's sent.
     */
    authorizeRequest?(options: AuthorizeRequestOptions): Promise<void>;
    /**
     * Allows to handle authentication challenges and to re-authorize the request.
     * The response containing the challenge is `options.response`.
     * If this method returns true, the underlying request will be sent once again.
     * The request may be modified before being sent.
     */
    authorizeRequestOnChallenge?(options: AuthorizeRequestOnChallengeOptions): Promise<boolean>;
}

/**
 * Shape of a Rest Level Client
 */
export declare interface Client {
    /**
     * The pipeline used by this client to make requests
     */
    pipeline: Pipeline;
    /**
     * This method will be used to send request that would check the path to provide
     * strong types. When used by the codegen this type gets overriden wit the generated
     * types. For example:
     * ```typescript
     * export type MyClient = Client & {
     *    path: Routes;
     * }
     * ```
     */
    path: Function;
    /**
     * This method allows arbitrary paths and doesn't provide strong types
     */
    pathUnchecked: PathUnchecked;
}

/**
 * General options that a Rest Level Client can take
 */
export declare type ClientOptions = PipelineOptions & {
    /**
     * Credentials information
     */
    credentials?: {
        /**
         * Authentication scopes for AAD
         */
        scopes?: string[];
        /**
         * Heder name for Client Secret authentication
         */
        apiKeyHeaderName?: string;
    };
    /**
     * Base url for the client
     * @deprecated This property is deprecated and will be removed soon, please use endpoint instead
     */
    baseUrl?: string;
    /**
     * Endpoint for the client
     */
    endpoint?: string;
    /**
     * Options for setting a custom apiVersion.
     */
    apiVersion?: string;
    /**
     * Option to allow calling http (insecure) endpoints
     */
    allowInsecureConnection?: boolean;
    /**
     * Additional policies to include in the HTTP pipeline.
     */
    additionalPolicies?: AdditionalPolicyConfig[];
    /**
     * Specify a custom HttpClient when making requests.
     */
    httpClient?: HttpClient;
    /**
     * Options to configure request/response logging.
     */
    loggingOptions?: LogPolicyOptions;
};

/**
 * Generates a SHA-256 hash.
 * @param content - The data to be included in the hash.
 * @param encoding - The textual encoding to use for the returned hash.
 */
export declare function computeSha256Hash(content: string, encoding: "base64" | "hex"): Promise<string>;

/**
 * Generates a SHA-256 HMAC signature.
 * @param key - The HMAC key represented as a base64 string, used to generate the cryptographic HMAC hash.
 * @param stringToSign - The data to be signed.
 * @param encoding - The textual encoding to use for the returned HMAC digest.
 */
export declare function computeSha256Hmac(key: string, stringToSign: string, encoding: "base64" | "hex"): Promise<string>;

/**
 * Creates an abortable promise.
 * @param buildPromise - A function that takes the resolve and reject functions as parameters.
 * @param options - The options for the abortable promise.
 * @returns A promise that can be aborted.
 */
export declare function createAbortablePromise<T>(buildPromise: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void, options?: CreateAbortablePromiseOptions): Promise<T>;

/**
 * Options for the createAbortablePromise function.
 */
export declare interface CreateAbortablePromiseOptions extends AbortOptions {
    /** A function to be called if the promise was aborted */
    cleanupBeforeAbort?: () => void;
}

/**
 * Create the correct HttpClient for the current environment.
 */
export declare function createDefaultHttpClient(): HttpClient;

/**
 * Creates a totally empty pipeline.
 * Useful for testing or creating a custom one.
 */
export declare function createEmptyPipeline(): Pipeline;

/**
 * Create an object that implements the File interface. This object is intended to be
 * passed into RequestBodyType.formData, and is not guaranteed to work as expected in
 * other situations.
 *
 * Use this function create a File object for use in RequestBodyType.formData in environments where the global File object is unavailable.
 *
 * @param content - the content of the file as a Uint8Array in memory.
 * @param name - the name of the file.
 * @param options - optional metadata about the file, e.g. file name, file size, MIME type.
 */
export declare function createFile(content: Uint8Array, name: string, options?: CreateFileOptions): File;

/**
 * Create an object that implements the File interface. This object is intended to be
 * passed into RequestBodyType.formData, and is not guaranteed to work as expected in
 * other situations.
 *
 * Use this function to:
 * - Create a File object for use in RequestBodyType.formData in environments where the
 *   global File object is unavailable.
 * - Create a File-like object from a readable stream without reading the stream into memory.
 *
 * @param stream - the content of the file as a callback returning a stream. When a File object made using createFile is
 *                  passed in a request's form data map, the stream will not be read into memory
 *                  and instead will be streamed when the request is made. In the event of a retry, the
 *                  stream needs to be read again, so this callback SHOULD return a fresh stream if possible.
 * @param name - the name of the file.
 * @param options - optional metadata about the file, e.g. file name, file size, MIME type.
 */
export declare function createFileFromStream(stream: () => ReadableStream<Uint8Array> | NodeJS.ReadableStream, name: string, options?: CreateFileFromStreamOptions): File;

/**
 * Extra options for createFile when a stream is being passed in.
 */
export declare interface CreateFileFromStreamOptions extends CreateFileOptions {
    /**
     * Size of the file represented by the stream in bytes.
     *
     * This will be used by the pipeline when calculating the Content-Length header
     * for the overall request.
     */
    size?: number;
}

/**
 * Options passed into createFile specifying metadata about the file.
 */
export declare interface CreateFileOptions {
    /**
     * The MIME type of the file.
     */
    type?: string;
    /**
     * Last modified time of the file as a UNIX timestamp.
     * This will default to the current date.
     */
    lastModified?: number;
    /**
     * relative path of this file when uploading a directory.
     */
    webkitRelativePath?: string;
}

/**
 * Creates an object that satisfies the `HttpHeaders` interface.
 * @param rawHeaders - A simple object representing initial headers
 */
export declare function createHttpHeaders(rawHeaders?: RawHttpHeadersInput): HttpHeaders;

/**
 * Create a new pipeline with a default set of customizable policies.
 * @param options - Options to configure a custom pipeline.
 */
export declare function createPipelineFromOptions(options: InternalPipelineOptions): Pipeline;

/**
 * Creates a new pipeline request with the given options.
 * This method is to allow for the easy setting of default values and not required.
 * @param options - The options to create the request with.
 */
export declare function createPipelineRequest(options: PipelineRequestOptions): PipelineRequest;

/**
 * Creates a rest error from a PathUnchecked response
 */
export declare function createRestError(response: PathUncheckedResponse): RestError;

/**
 * Creates a rest error from an error message and a PathUnchecked response
 */
export declare function createRestError(message: string, response: PathUncheckedResponse): RestError;

/**
 * Creates a new tracing client.
 *
 * @param options - Options used to configure the tracing client.
 * @returns - An instance of {@link TracingClient}.
 */
export declare function createTracingClient(options: TracingClientOptions): TracingClient;

/**
 * A log function that can be dynamically enabled and redirected.
 */
export declare interface Debugger {
    /**
     * Logs the given arguments to the `log` method.
     */
    (...args: any[]): void;
    /**
     * True if this logger is active and logging.
     */
    enabled: boolean;
    /**
     * Used to cleanup/remove this logger.
     */
    destroy: () => boolean;
    /**
     * The current log method. Can be overridden to redirect output.
     */
    log: (...args: any[]) => void;
    /**
     * The namespace of this logger.
     */
    namespace: string;
    /**
     * Extends this logger with a child namespace.
     * Namespaces are separated with a ':' character.
     */
    extend: (namespace: string) => Debugger;
}

/**
 * A policy to enable response decompression according to Accept-Encoding header
 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding
 */
export declare function decompressResponsePolicy(): PipelinePolicy;

/**
 * The programmatic identifier of the decompressResponsePolicy.
 */
export declare const decompressResponsePolicyName = "decompressResponsePolicy";

/**
 * A policy that retries according to three strategies:
 * - When the server sends a 429 response with a Retry-After header.
 * - When there are errors in the underlying transport layer (e.g. DNS lookup failures).
 * - Or otherwise if the outgoing request fails, it will retry with an exponentially increasing delay.
 */
export declare function defaultRetryPolicy(options?: DefaultRetryPolicyOptions): PipelinePolicy;

/**
 * Options that control how to retry failed requests.
 */
export declare interface DefaultRetryPolicyOptions extends PipelineRetryOptions {
}

/**
 * A wrapper for setTimeout that resolves a promise after timeInMs milliseconds.
 * @param timeInMs - The number of milliseconds to be delayed.
 * @param options - The options for delay - currently abort options
 * @returns Promise that is resolved after timeInMs
 */
export declare function delay(timeInMs: number, options?: DelayOptions_2): Promise<void>;

/**
 * Options for support abort functionality for the delay method
 */
declare interface DelayOptions_2 extends AbortOptions {
}
export { DelayOptions_2 as DelayOptions }

/** The supported character encoding type */
export declare type EncodingType = "utf-8" | "base64" | "base64url" | "hex";

/** The error object. */
export declare interface ErrorModel {
    /** One of a server-defined set of error codes. */
    code: string;
    /** A human-readable representation of the error. */
    message: string;
    /** The target of the error. */
    target?: string;
    /** An array of details about specific errors that led to this reported error. */
    details: Array<ErrorModel>;
    /** An object containing more specific information than the current object about the error. */
    innererror?: InnerError;
}

/** A response containing error details. */
export declare interface ErrorResponse {
    /** The error object. */
    error: ErrorModel;
}

/**
 * A simple object that provides form data, as if from a browser form.
 */
export declare type FormDataMap = {
    [key: string]: FormDataValue | FormDataValue[];
};

/**
 * A policy that encodes FormData on the request into the body.
 */
export declare function formDataPolicy(): PipelinePolicy;

/**
 * The programmatic identifier of the formDataPolicy.
 */
export declare const formDataPolicyName = "formDataPolicy";

/**
 * Each form data entry can be a string, Blob, or a File. If you wish to pass a file with a name but do not have
 * access to the File class, you can use the createFile helper to create one.
 */
export declare type FormDataValue = string | Blob | File;

/**
 * Wrapper object for http request and response. Deserialized object is stored in
 * the `parsedBody` property when the response body is received in JSON.
 */
export declare interface FullOperationResponse extends PipelineResponse {
    /**
     * The raw HTTP response headers.
     */
    rawHeaders?: RawHttpHeaders;
    /**
     * The response body as parsed JSON.
     */
    parsedBody?: RequestBodyType;
    /**
     * The request that generated the response.
     */
    request: PipelineRequest;
}

/**
 * Creates a client with a default pipeline
 * @param endpoint - Base endpoint for the client
 * @param options - Client options
 */
export declare function getClient(endpoint: string, options?: ClientOptions): Client;

/**
 * Creates a client with a default pipeline
 * @param endpoint - Base endpoint for the client
 * @param credentials - Credentials to authenticate the requests
 * @param options - Client options
 */
export declare function getClient(endpoint: string, credentials?: TokenCredential | KeyCredential, options?: ClientOptions): Client;

/**
 * This method converts a proxy url into `ProxySettings` for use with ProxyPolicy.
 * If no argument is given, it attempts to parse a proxy URL from the environment
 * variables `HTTPS_PROXY` or `HTTP_PROXY`.
 * @param proxyUrl - The url of the proxy to use. May contain authentication information.
 * @deprecated - Internally this method is no longer necessary when setting proxy information.
 */
export declare function getDefaultProxySettings(proxyUrl?: string): ProxySettings | undefined;

/**
 * Given what is thought to be an error object, return the message if possible.
 * If the message is missing, returns a stringified version of the input.
 * @param e - Something thrown from a try block
 * @returns The error message or a string of the input
 */
export declare function getErrorMessage(e: unknown): string;

/**
 * Returns a random integer value between a lower and upper bound,
 * inclusive of both bounds.
 * Note that this uses Math.random and isn't secure. If you need to use
 * this for any kind of security purpose, find a better source of random.
 * @param min - The smallest integer value allowed.
 * @param max - The largest integer value allowed.
 */
export declare function getRandomIntegerInclusive(min: number, max: number): number;

/**
 * Defines options for TokenCredential.getToken.
 */
export declare interface GetTokenOptions {
    /**
     * The signal which can be used to abort requests.
     */
    abortSignal?: AbortSignalLike;
    /**
     * Options used when creating and sending HTTP requests for this operation.
     */
    requestOptions?: {
        /**
         * The number of milliseconds a request can take before automatically being terminated.
         */
        timeout?: number;
    };
    /**
     * Options used when tracing is enabled.
     */
    tracingOptions?: {
        /**
         * Tracing Context for the current request.
         */
        tracingContext?: TracingContext;
    };
    /**
     * Claim details to perform the Continuous Access Evaluation authentication flow
     */
    claims?: string;
    /**
     * Indicates whether to enable the Continuous Access Evaluation authentication flow
     */
    enableCae?: boolean;
    /**
     * Allows specifying a tenantId. Useful to handle challenges that provide tenant Id hints.
     */
    tenantId?: string;
}

/**
 * Http Response which body is a NodeJS stream object
 */
export declare type HttpBrowserStreamResponse = HttpResponse & {
    /**
     * Streamable body
     */
    body?: ReadableStream<Uint8Array>;
};

/**
 * The required interface for a client that makes HTTP requests
 * on behalf of a pipeline.
 */
export declare interface HttpClient {
    /**
     * The method that makes the request and returns a response.
     */
    sendRequest: SendRequest;
}

/**
 * Represents a set of HTTP headers on a request/response.
 * Header names are treated as case insensitive.
 */
export declare interface HttpHeaders extends Iterable<[string, string]> {
    /**
     * Returns the value of a specific header or undefined if not set.
     * @param name - The name of the header to retrieve.
     */
    get(name: string): string | undefined;
    /**
     * Returns true if the specified header exists.
     * @param name - The name of the header to check.
     */
    has(name: string): boolean;
    /**
     * Sets a specific header with a given value.
     * @param name - The name of the header to set.
     * @param value - The value to use for the header.
     */
    set(name: string, value: string | number | boolean): void;
    /**
     * Removes a specific header from the collection.
     * @param name - The name of the header to delete.
     */
    delete(name: string): void;
    /**
     * Accesses a raw JS object that acts as a simple map
     * of header names to values.
     */
    toJSON(options?: {
        preserveCase?: boolean;
    }): RawHttpHeaders;
}

/**
 * Supported HTTP methods to use when making requests.
 */
export declare type HttpMethods = "GET" | "PUT" | "POST" | "DELETE" | "PATCH" | "HEAD" | "OPTIONS" | "TRACE";

/**
 * Http Response which body is a NodeJS stream object
 */
export declare type HttpNodeStreamResponse = HttpResponse & {
    /**
     * Streamable body
     */
    body?: NodeJS.ReadableStream;
};

/**
 * Represents the shape of an HttpResponse
 */
export declare type HttpResponse = {
    /**
     * The request that generated this response.
     */
    request: PipelineRequest;
    /**
     * The HTTP response headers.
     */
    headers: RawHttpHeaders;
    /**
     * Parsed body
     */
    body: unknown;
    /**
     * The HTTP status code of the response.
     */
    status: string;
};

/** An object containing more specific information about the error. As per Microsoft One API guidelines - https://github.com/Microsoft/api-guidelines/blob/vNext/Guidelines.md#7102-error-condition-responses. */
export declare interface InnerError {
    /** One of a server-defined set of error codes. */
    code: string;
    /** Inner error. */
    innererror?: InnerError;
}

/**
 * Represents an implementation agnostic instrumenter.
 */
export declare interface Instrumenter {
    /**
     * Creates a new {@link TracingSpan} with the given name and options and sets it on a new context.
     * @param name - The name of the span. By convention this should be `${className}.${methodName}`.
     * @param spanOptions - The options to use when creating the span.
     *
     * @returns A {@link TracingSpan} that can be used to end the span, and the context this span has been set on.
     */
    startSpan(name: string, spanOptions: InstrumenterSpanOptions): {
        span: TracingSpan;
        tracingContext: TracingContext;
    };
    /**
     * Wraps a callback with an active context and calls the callback.
     * Depending on the implementation, this may set the globally available active context.
     *
     * @param context - The {@link TracingContext} to use as the active context in the scope of the callback.
     * @param callback - The callback to be invoked with the given context set as the globally active context.
     * @param callbackArgs - The callback arguments.
     */
    withContext<CallbackArgs extends unknown[], Callback extends (...args: CallbackArgs) => ReturnType<Callback>>(context: TracingContext, callback: Callback, ...callbackArgs: CallbackArgs): ReturnType<Callback>;
    /**
     * Provides an implementation-specific method to parse a {@link https://www.w3.org/TR/trace-context/#traceparent-header}
     * into a {@link TracingSpanContext} which can be used to link non-parented spans together.
     */
    parseTraceparentHeader(traceparentHeader: string): TracingContext | undefined;
    /**
     * Provides an implementation-specific method to serialize a {@link TracingSpan} to a set of headers.
     * @param tracingContext - The context containing the span to serialize.
     */
    createRequestHeaders(tracingContext?: TracingContext): Record<string, string>;
}

/**
 * Options passed to {@link Instrumenter.startSpan} as a superset of {@link TracingSpanOptions}.
 */
export declare interface InstrumenterSpanOptions extends TracingSpanOptions {
    /** The name of the package invoking this trace. */
    packageName: string;
    /** The version of the package invoking this trace. */
    packageVersion?: string;
    /** The current tracing context. Defaults to an implementation-specific "active" context. */
    tracingContext?: TracingContext;
}

/**
 * Defines options that are used to configure internal options of
 * the HTTP pipeline for an SDK client.
 */
export declare interface InternalPipelineOptions extends PipelineOptions {
    /**
     * Options to configure request/response logging.
     */
    loggingOptions?: LogPolicyOptions;
}

/**
 * A constant that indicates whether the environment the code is running is a Web Browser.
 */
export declare const isBrowser: boolean;

/**
 * A constant that indicates whether the environment the code is running is Bun.sh.
 */
export declare const isBun: boolean;

/**
 * Helper TypeGuard that checks if something is defined or not.
 * @param thing - Anything
 */
export declare function isDefined<T>(thing: T | undefined | null): thing is T;

/**
 * A constant that indicates whether the environment the code is running is Deno.
 */
export declare const isDeno: boolean;

/**
 * Typeguard for an error object shape (has name and message)
 * @param e - Something caught by a catch clause.
 */
export declare function isError(e: unknown): e is Error;

/**
 * Tests an object to determine whether it implements KeyCredential.
 *
 * @param credential - The assumed KeyCredential to be tested.
 */
export declare function isKeyCredential(credential: unknown): credential is KeyCredential;

/**
 * A constant that indicates whether the environment the code is running is a Node.js compatible environment.
 * @deprecated Use `isNodeLike` instead.
 */
export declare const isNode: boolean;

/**
 * A constant that indicates whether the environment the code is running is a Node.js compatible environment.
 */
export declare const isNodeLike: boolean;

/**
 * A constant that indicates whether the environment the code is running is Node.JS.
 */
export declare const isNodeRuntime: boolean;

/**
 * Helper to determine when an input is a generic JS object.
 * @returns true when input is an object type that is not null, Array, RegExp, or Date.
 */
export declare function isObject(input: unknown): input is UnknownObject;

/**
 * Helper TypeGuard that checks if the input is an object with the specified properties.
 * @param thing - Anything.
 * @param properties - The name of the properties that should appear in the object.
 */
export declare function isObjectWithProperties<Thing, PropertyName extends string>(thing: Thing, properties: PropertyName[]): thing is Thing & Record<PropertyName, unknown>;

/**
 * A constant that indicates whether the environment the code is running is in React-Native.
 */
export declare const isReactNative: boolean;

/**
 * Typeguard for RestError
 * @param e - Something caught by a catch clause.
 */
export declare function isRestError(e: unknown): e is RestError;

/**
 * A constant that indicates whether the environment the code is running is a Web Worker.
 */
export declare const isWebWorker: boolean;

/**
 * Represents a credential defined by a static API key.
 */
export declare interface KeyCredential {
    /**
     * The value of the API key represented as a string
     */
    readonly key: string;
}

/**
 * An interface compatible with NodeJS's `tls.KeyObject`.
 * We want to avoid publicly re-exporting the actual interface,
 * since it might vary across runtime versions.
 */
export declare interface KeyObject {
    /**
     * Private keys in PEM format.
     */
    pem: string | Buffer;
    /**
     * Optional passphrase.
     */
    passphrase?: string | undefined;
}

/**
 * A policy that logs all requests and responses.
 * @param options - Options to configure logPolicy.
 */
export declare function logPolicy(options?: LogPolicyOptions): PipelinePolicy;

/**
 * The programmatic identifier of the logPolicy.
 */
export declare const logPolicyName = "logPolicy";

/**
 * Options to configure the logPolicy.
 */
export declare interface LogPolicyOptions {
    /**
     * Header names whose values will be logged when logging is enabled.
     * Defaults include a list of well-known safe headers. Any headers
     * specified in this field will be added to that list.  Any other values will
     * be written to logs as "REDACTED".
     */
    additionalAllowedHeaderNames?: string[];
    /**
     * Query string names whose values will be logged when logging is enabled. By default no
     * query string values are logged.
     */
    additionalAllowedQueryParameters?: string[];
    /**
     * The log function to use for writing pipeline logs.
     * Defaults to core-http's built-in logger.
     * Compatible with the `debug` library.
     */
    logger?: Debugger;
}

/**
 * Pipeline policy for multipart requests
 */
export declare function multipartPolicy(): PipelinePolicy;

/**
 * Name of multipart policy
 */
export declare const multipartPolicyName = "multipartPolicy";

/**
 * A request body consisting of multiple parts.
 */
export declare interface MultipartRequestBody {
    /**
     * The parts of the request body.
     */
    parts: BodyPart[];
    /**
     * The boundary separating each part of the request body.
     * If not specified, a random boundary will be generated.
     *
     * When specified, '--' will be prepended to the boundary in the request to ensure the boundary follows the specification.
     */
    boundary?: string;
}

/**
 * Helper TypeGuard that checks if the input is an object with the specified property.
 * @param thing - Any object.
 * @param property - The name of the property that should appear in the object.
 */
export declare function objectHasProperty<Thing, PropertyName extends string>(thing: Thing, property: PropertyName): thing is Thing & Record<PropertyName, unknown>;

/**
 * The base options type for all operations.
 */
export declare interface OperationOptions {
    /**
     * The signal which can be used to abort requests.
     */
    abortSignal?: AbortSignalLike;
    /**
     * Options used when creating and sending HTTP requests for this operation.
     */
    requestOptions?: OperationRequestOptions;
    /**
     * Options used when tracing is enabled.
     */
    tracingOptions?: OperationTracingOptions;
    /**
     * A function to be called each time a response is received from the server
     * while performing the requested operation.
     * May be called multiple times.
     */
    onResponse?: RawResponseCallback;
}

/**
 * Helper function to convert OperationOptions to RequestParameters
 * @param options - the options that are used by Modular layer to send the request
 * @returns the result of the conversion in RequestParameters of RLC layer
 */
export declare function operationOptionsToRequestParameters(options: OperationOptions): RequestParameters;

/**
 * Options used when creating and sending HTTP requests for this operation.
 */
export declare interface OperationRequestOptions {
    /**
     * User defined custom request headers that
     * will be applied before the request is sent.
     */
    headers?: RawHttpHeadersInput;
    /**
     * The number of milliseconds a request can take before automatically being terminated.
     */
    timeout?: number;
    /**
     * Callback which fires upon upload progress.
     */
    onUploadProgress?: (progress: TransferProgressEvent) => void;
    /**
     * Callback which fires upon download progress.
     */
    onDownloadProgress?: (progress: TransferProgressEvent) => void;
    /**
     * Set to true if the request is sent over HTTP instead of HTTPS
     */
    allowInsecureConnection?: boolean;
    /**
     * Set to true if you want to skip encoding the path parameters
     */
    skipUrlEncoding?: boolean;
}

/**
 * Tracing options to set on an operation.
 */
export declare interface OperationTracingOptions {
    /** The context to use for created Tracing Spans. */
    tracingContext?: TracingContext;
}

/**
 * A utility type for when we know a TracingContext has been set
 * as part of an operation's options.
 */
export declare type OptionsWithTracingContext<Options extends {
    tracingOptions?: OperationTracingOptions;
}> = Options & {
    tracingOptions: {
        tracingContext: TracingContext;
    };
};

/**
 * Helper type used to detect parameters in a path template
 * text surrounded by \{\} will be considered a path parameter
 */
export declare type PathParameters<TRoute extends string> = TRoute extends `${infer _Head}/{${infer _Param}}${infer Tail}` ? [
pathParameter: string,
...pathParameters: PathParameters<Tail>
] : [
];

/**
 * Defines the signature for pathUnchecked.
 */
export declare type PathUnchecked = <TPath extends string>(path: TPath, ...args: PathParameters<TPath>) => ResourceMethods<StreamableMethod>;

/**
 * Type to use with pathUnchecked, overrides the body type to any to allow flexibility
 */
export declare type PathUncheckedResponse = HttpResponse & {
    body: any;
};

/**
 * Represents a pipeline for making a HTTP request to a URL.
 * Pipelines can have multiple policies to manage manipulating each request
 * before and after it is made to the server.
 */
export declare interface Pipeline {
    /**
     * Add a new policy to the pipeline.
     * @param policy - A policy that manipulates a request.
     * @param options - A set of options for when the policy should run.
     */
    addPolicy(policy: PipelinePolicy, options?: AddPipelineOptions): void;
    /**
     * Remove a policy from the pipeline.
     * @param options - Options that let you specify which policies to remove.
     */
    removePolicy(options: {
        name?: string;
        phase?: PipelinePhase;
    }): PipelinePolicy[];
    /**
     * Uses the pipeline to make a HTTP request.
     * @param httpClient - The HttpClient that actually performs the request.
     * @param request - The request to be made.
     */
    sendRequest(httpClient: HttpClient, request: PipelineRequest): Promise<PipelineResponse>;
    /**
     * Returns the current set of policies in the pipeline in the order in which
     * they will be applied to the request. Later in the list is closer to when
     * the request is performed.
     */
    getOrderedPolicies(): PipelinePolicy[];
    /**
     * Duplicates this pipeline to allow for modifying an existing one without mutating it.
     */
    clone(): Pipeline;
}

/**
 * Defines options that are used to configure the HTTP pipeline for
 * an SDK client.
 */
export declare interface PipelineOptions {
    /**
     * Options that control how to retry failed requests.
     */
    retryOptions?: PipelineRetryOptions;
    /**
     * Options to configure a proxy for outgoing requests.
     */
    proxyOptions?: ProxySettings;
    /** Options for configuring TLS authentication */
    tlsOptions?: TlsSettings;
    /**
     * Options for how redirect responses are handled.
     */
    redirectOptions?: RedirectPolicyOptions;
    /**
     * Options for adding user agent details to outgoing requests.
     */
    userAgentOptions?: UserAgentPolicyOptions;
    /**
     * Options for setting common telemetry and tracing info to outgoing requests.
     */
    telemetryOptions?: TelemetryOptions;
}

/**
 * Policies are executed in phases.
 * The execution order is:
 * 1. Serialize Phase
 * 2. Policies not in a phase
 * 3. Deserialize Phase
 * 4. Retry Phase
 * 5. Sign Phase
 */
export declare type PipelinePhase = "Deserialize" | "Serialize" | "Retry" | "Sign";

/**
 * A pipeline policy manipulates a request as it travels through the pipeline.
 * It is conceptually a middleware that is allowed to modify the request before
 * it is made as well as the response when it is received.
 */
export declare interface PipelinePolicy {
    /**
     * The policy name. Must be a unique string in the pipeline.
     */
    name: string;
    /**
     * The main method to implement that manipulates a request/response.
     * @param request - The request being performed.
     * @param next - The next policy in the pipeline. Must be called to continue the pipeline.
     */
    sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse>;
}

/**
 * Metadata about a request being made by the pipeline.
 */
export declare interface PipelineRequest {
    /**
     * The URL to make the request to.
     */
    url: string;
    /**
     * The HTTP method to use when making the request.
     */
    method: HttpMethods;
    /**
     * The HTTP headers to use when making the request.
     */
    headers: HttpHeaders;
    /**
     * The number of milliseconds a request can take before automatically being terminated.
     * If the request is terminated, an `AbortError` is thrown.
     * Defaults to 0, which disables the timeout.
     */
    timeout: number;
    /**
     * Indicates whether the user agent should send cookies from the other domain in the case of cross-origin requests.
     * Defaults to false.
     */
    withCredentials: boolean;
    /**
     * A unique identifier for the request. Used for logging and tracing.
     */
    requestId: string;
    /**
     * The HTTP body content (if any)
     */
    body?: RequestBodyType;
    /**
     * Body for a multipart request.
     */
    multipartBody?: MultipartRequestBody;
    /**
     * To simulate a browser form post
     */
    formData?: FormDataMap;
    /**
     * A list of response status codes whose corresponding PipelineResponse body should be treated as a stream.
     * When streamResponseStatusCodes contains the value Number.POSITIVE_INFINITY any status would be treated as a stream.
     */
    streamResponseStatusCodes?: Set<number>;
    /**
     * Proxy configuration.
     */
    proxySettings?: ProxySettings;
    /**
     * If the connection should not be reused.
     */
    disableKeepAlive?: boolean;
    /**
     * Used to abort the request later.
     */
    abortSignal?: AbortSignalLike;
    /**
     * Tracing options to use for any created Spans.
     */
    tracingOptions?: OperationTracingOptions;
    /**
     * Callback which fires upon upload progress.
     */
    onUploadProgress?: (progress: TransferProgressEvent) => void;
    /** Callback which fires upon download progress. */
    onDownloadProgress?: (progress: TransferProgressEvent) => void;
    /** Set to true if the request is sent over HTTP instead of HTTPS */
    allowInsecureConnection?: boolean;
    /**
     * NODEJS ONLY
     *
     * A Node-only option to provide a custom `http.Agent`/`https.Agent`.
     * Does nothing when running in the browser.
     */
    agent?: Agent;
    /**
     * BROWSER ONLY
     *
     * A browser only option to enable browser Streams. If this option is set and a response is a stream
     * the response will have a property `browserStream` instead of `blobBody` which will be undefined.
     *
     * Default value is false
     */
    enableBrowserStreams?: boolean;
    /** Settings for configuring TLS authentication */
    tlsSettings?: TlsSettings;
}

/**
 * Settings to initialize a request.
 * Almost equivalent to Partial<PipelineRequest>, but url is mandatory.
 */
export declare interface PipelineRequestOptions {
    /**
     * The URL to make the request to.
     */
    url: string;
    /**
     * The HTTP method to use when making the request.
     */
    method?: HttpMethods;
    /**
     * The HTTP headers to use when making the request.
     */
    headers?: HttpHeaders;
    /**
     * The number of milliseconds a request can take before automatically being terminated.
     * If the request is terminated, an `AbortError` is thrown.
     * Defaults to 0, which disables the timeout.
     */
    timeout?: number;
    /**
     * If credentials (cookies) should be sent along during an XHR.
     * Defaults to false.
     */
    withCredentials?: boolean;
    /**
     * A unique identifier for the request. Used for logging and tracing.
     */
    requestId?: string;
    /**
     * The HTTP body content (if any)
     */
    body?: RequestBodyType;
    /**
     * Body for a multipart request.
     */
    multipartBody?: MultipartRequestBody;
    /**
     * To simulate a browser form post
     */
    formData?: FormDataMap;
    /**
     * A list of response status codes whose corresponding PipelineResponse body should be treated as a stream.
     */
    streamResponseStatusCodes?: Set<number>;
    /**
     * BROWSER ONLY
     *
     * A browser only option to enable use of the Streams API. If this option is set and streaming is used
     * (see `streamResponseStatusCodes`), the response will have a property `browserStream` instead of
     * `blobBody` which will be undefined.
     *
     * Default value is false
     */
    enableBrowserStreams?: boolean;
    /**
     * Proxy configuration.
     */
    proxySettings?: ProxySettings;
    /**
     * If the connection should not be reused.
     */
    disableKeepAlive?: boolean;
    /**
     * Used to abort the request later.
     */
    abortSignal?: AbortSignalLike;
    /**
     * Options used to create a span when tracing is enabled.
     */
    tracingOptions?: OperationTracingOptions;
    /**
     * Callback which fires upon upload progress.
     */
    onUploadProgress?: (progress: TransferProgressEvent) => void;
    /** Callback which fires upon download progress. */
    onDownloadProgress?: (progress: TransferProgressEvent) => void;
    /** Set to true if the request is sent over HTTP instead of HTTPS */
    allowInsecureConnection?: boolean;
}

/**
 * Metadata about a response received by the pipeline.
 */
export declare interface PipelineResponse {
    /**
     * The request that generated this response.
     */
    request: PipelineRequest;
    /**
     * The HTTP status code of the response.
     */
    status: number;
    /**
     * The HTTP response headers.
     */
    headers: HttpHeaders;
    /**
     * The response body as text (string format)
     */
    bodyAsText?: string | null;
    /**
     * BROWSER ONLY
     *
     * The response body as a browser Blob.
     * Always undefined in node.js.
     */
    blobBody?: Promise<Blob>;
    /**
     * BROWSER ONLY
     *
     * The response body as a browser ReadableStream.
     * Always undefined in node.js.
     */
    browserStreamBody?: ReadableStream<Uint8Array>;
    /**
     * NODEJS ONLY
     *
     * The response body as a node.js Readable stream.
     * Always undefined in the browser.
     */
    readableStreamBody?: NodeJS.ReadableStream;
}

/**
 * Options that control how to retry failed requests.
 */
export declare interface PipelineRetryOptions {
    /**
     * The maximum number of retry attempts. Defaults to 3.
     */
    maxRetries?: number;
    /**
     * The amount of delay in milliseconds between retry attempts. Defaults to 1000
     * (1 second). The delay increases exponentially with each retry up to a maximum
     * specified by maxRetryDelayInMs.
     */
    retryDelayInMs?: number;
    /**
     * The maximum delay in milliseconds allowed before retrying an operation. Defaults
     * to 64000 (64 seconds).
     */
    maxRetryDelayInMs?: number;
}

/**
 * A policy that allows one to apply proxy settings to all requests.
 * If not passed static settings, they will be retrieved from the HTTPS_PROXY
 * or HTTP_PROXY environment variables.
 * @param proxySettings - ProxySettings to use on each request.
 * @param options - additional settings, for example, custom NO_PROXY patterns
 */
export declare function proxyPolicy(proxySettings?: ProxySettings, options?: {
    /** a list of patterns to override those loaded from NO_PROXY environment variable. */
    customNoProxyList?: string[];
}): PipelinePolicy;

/**
 * The programmatic identifier of the proxyPolicy.
 */
export declare const proxyPolicyName = "proxyPolicy";

/**
 * Options to configure a proxy for outgoing requests (Node.js only).
 */
export declare interface ProxySettings {
    /**
     * The proxy's host address.
     */
    host: string;
    /**
     * The proxy host's port.
     */
    port: number;
    /**
     * The user name to authenticate with the proxy, if required.
     */
    username?: string;
    /**
     * The password to authenticate with the proxy, if required.
     */
    password?: string;
}

/**
 * An interface compatible with NodeJS's `tls.PxfObject`.
 * We want to avoid publicly re-exporting the actual interface,
 * since it might vary across runtime versions.
 */
export declare interface PxfObject {
    /**
     * PFX or PKCS12 encoded private key and certificate chain.
     */
    buf: string | Buffer;
    /**
     * Optional passphrase.
     */
    passphrase?: string | undefined;
}

/**
 * Generated Universally Unique Identifier
 *
 * @returns RFC4122 v4 UUID.
 */
export declare function randomUUID(): string;

/**
 * A HttpHeaders collection represented as a simple JSON object.
 */
export declare type RawHttpHeaders = {
    [headerName: string]: string;
};

/**
 * A HttpHeaders collection for input, represented as a simple JSON object.
 */
export declare type RawHttpHeadersInput = Record<string, string | number | boolean>;

/**
 * A function to be called each time a response is received from the server
 * while performing the requested operation.
 * May be called multiple times.
 */
export declare type RawResponseCallback = (rawResponse: FullOperationResponse, error?: unknown) => void;

/**
 * A policy to follow Location headers from the server in order
 * to support server-side redirection.
 * In the browser, this policy is not used.
 * @param options - Options to control policy behavior.
 */
export declare function redirectPolicy(options?: RedirectPolicyOptions): PipelinePolicy;

/**
 * The programmatic identifier of the redirectPolicy.
 */
export declare const redirectPolicyName = "redirectPolicy";

/**
 * Options for how redirect responses are handled.
 */
export declare interface RedirectPolicyOptions {
    /**
     * The maximum number of times the redirect URL will be tried before
     * failing.  Defaults to 20.
     */
    maxRetries?: number;
}

/**
 * Types of bodies supported on the request.
 * NodeJS.ReadableStream and () =\> NodeJS.ReadableStream is Node only.
 * Blob, ReadableStream<Uint8Array>, and () =\> ReadableStream<Uint8Array> are browser only.
 */
export declare type RequestBodyType = NodeJS.ReadableStream | (() => NodeJS.ReadableStream) | ReadableStream<Uint8Array> | (() => ReadableStream<Uint8Array>) | Blob | ArrayBuffer | ArrayBufferView | FormData | string | null;

/**
 * Shape of the default request parameters, this may be overriden by the specific
 * request types to provide strong types
 */
export declare type RequestParameters = {
    /**
     * Headers to send along with the request
     */
    headers?: RawHttpHeadersInput;
    /**
     * Sets the accept header to send to the service
     * defaults to 'application/json'. If also a header "accept" is set
     * this property will take precedence.
     */
    accept?: string;
    /**
     * Body to send with the request
     */
    body?: unknown;
    /**
     * Query parameters to send with the request
     */
    queryParameters?: Record<string, unknown>;
    /**
     * Set an explicit content-type to send with the request. If also a header "content-type" is set
     * this property will take precedence.
     */
    contentType?: string;
    /** Set to true if the request is sent over HTTP instead of HTTPS */
    allowInsecureConnection?: boolean;
    /** Set to true if you want to skip encoding the path parameters */
    skipUrlEncoding?: boolean;
    /**
     * Path parameters for custom the base url
     */
    pathParameters?: Record<string, any>;
    /**
     * The number of milliseconds a request can take before automatically being terminated.
     */
    timeout?: number;
    /**
     * Callback which fires upon upload progress.
     */
    onUploadProgress?: (progress: TransferProgressEvent) => void;
    /**
     * Callback which fires upon download progress.
     */
    onDownloadProgress?: (progress: TransferProgressEvent) => void;
    /**
     * The signal which can be used to abort requests.
     */
    abortSignal?: AbortSignalLike;
    /**
     * Options used when tracing is enabled.
     */
    tracingOptions?: OperationTracingOptions;
    /**
     * A function to be called each time a response is received from the server
     * while performing the requested operation.
     * May be called multiple times.
     */
    onResponse?: RawResponseCallback;
};

/**
 * A narrower version of TypeScript 4.5's Awaited type which Recursively
 * unwraps the "awaited type", emulating the behavior of `await`.
 */
export declare type Resolved<T> = T extends {
    then(onfulfilled: infer F): any;
} ? F extends (value: infer V) => any ? Resolved<V> : never : T;

/**
 * Defines the methods that can be called on a resource
 */
export declare interface ResourceMethods<TResponse = PromiseLike<PathUncheckedResponse>> {
    /**
     * Definition of the GET HTTP method for a resource
     */
    get: (options?: RequestParameters) => TResponse;
    /**
     * Definition of the POST HTTP method for a resource
     */
    post: (options?: RequestParameters) => TResponse;
    /**
     * Definition of the PUT HTTP method for a resource
     */
    put: (options?: RequestParameters) => TResponse;
    /**
     * Definition of the PATCH HTTP method for a resource
     */
    patch: (options?: RequestParameters) => TResponse;
    /**
     * Definition of the DELETE HTTP method for a resource
     */
    delete: (options?: RequestParameters) => TResponse;
    /**
     * Definition of the HEAD HTTP method for a resource
     */
    head: (options?: RequestParameters) => TResponse;
    /**
     * Definition of the OPTIONS HTTP method for a resource
     */
    options: (options?: RequestParameters) => TResponse;
    /**
     * Definition of the TRACE HTTP method for a resource
     */
    trace: (options?: RequestParameters) => TResponse;
}

/**
 * A custom error type for failed pipeline requests.
 */
export declare class RestError extends Error {
    /**
     * Something went wrong when making the request.
     * This means the actual request failed for some reason,
     * such as a DNS issue or the connection being lost.
     */
    static readonly REQUEST_SEND_ERROR: string;
    /**
     * This means that parsing the response from the server failed.
     * It may have been malformed.
     */
    static readonly PARSE_ERROR: string;
    /**
     * The code of the error itself (use statics on RestError if possible.)
     */
    code?: string;
    /**
     * The HTTP status code of the request (if applicable.)
     */
    statusCode?: number;
    /**
     * The request that was made.
     */
    request?: PipelineRequest;
    /**
     * The response received (if any.)
     */
    response?: PipelineResponse;
    /**
     * Bonus property set by the throw site.
     */
    details?: unknown;
    constructor(message: string, options?: RestErrorOptions);
}

/**
 * The options supported by RestError.
 */
export declare interface RestErrorOptions {
    /**
     * The code of the error itself (use statics on RestError if possible.)
     */
    code?: string;
    /**
     * The HTTP status code of the request (if applicable.)
     */
    statusCode?: number;
    /**
     * The request that was made.
     */
    request?: PipelineRequest;
    /**
     * The response received (if any.)
     */
    response?: PipelineResponse;
}

/**
 * A simple interface for making a pipeline request and receiving a response.
 */
export declare type SendRequest = (request: PipelineRequest) => Promise<PipelineResponse>;

/**
 * Represents the statuses that can be passed to {@link TracingSpan.setStatus}.
 *
 * By default, all spans will be created with status "unset".
 */
export declare type SpanStatus = SpanStatusSuccess | SpanStatusError;

/**
 * Status representing an error that can be sent to {@link TracingSpan.setStatus}
 */
export declare type SpanStatusError = {
    status: "error";
    error?: Error | string;
};

/**
 * Status representing a successful operation that can be sent to {@link TracingSpan.setStatus}
 */
export declare type SpanStatusSuccess = {
    status: "success";
};

/**
 * Defines the type for a method that supports getting the response body as
 * a raw stream
 */
export declare type StreamableMethod<TResponse = PathUncheckedResponse> = PromiseLike<TResponse> & {
    asNodeStream: () => Promise<HttpNodeStreamResponse>;
    asBrowserStream: () => Promise<HttpBrowserStreamResponse>;
};

/**
 * The helper that transforms string to specific character encoded bytes array.
 * @param value - the string to be converted
 * @param format - the format we use to decode the value
 * @returns a uint8array
 */
export declare function stringToUint8Array(value: string, format: EncodingType): Uint8Array;

/**
 * Defines options that are used to configure common telemetry and tracing info
 */
export declare interface TelemetryOptions {
    /**
     * The name of the header to pass the request ID to.
     */
    clientRequestIdHeaderName?: string;
}

/**
 * Gets a pipeline policy that adds the client certificate to the HttpClient agent for authentication.
 */
export declare function tlsPolicy(tlsSettings?: TlsSettings): PipelinePolicy;

/**
 * Name of the TLS Policy
 */
export declare const tlsPolicyName = "tlsPolicy";

/**
 * Represents a certificate for TLS authentication.
 */
export declare interface TlsSettings {
    /**
     * Optionally override the trusted CA certificates. Default is to trust
     * the well-known CAs curated by Mozilla. Mozilla's CAs are completely
     * replaced when CAs are explicitly specified using this option.
     */
    ca?: string | Buffer | Array<string | Buffer> | undefined;
    /**
     *  Cert chains in PEM format. One cert chain should be provided per
     *  private key. Each cert chain should consist of the PEM formatted
     *  certificate for a provided private key, followed by the PEM
     *  formatted intermediate certificates (if any), in order, and not
     *  including the root CA (the root CA must be pre-known to the peer,
     *  see ca). When providing multiple cert chains, they do not have to
     *  be in the same order as their private keys in key. If the
     *  intermediate certificates are not provided, the peer will not be
     *  able to validate the certificate, and the handshake will fail.
     */
    cert?: string | Buffer | Array<string | Buffer> | undefined;
    /**
     * Private keys in PEM format. PEM allows the option of private keys
     * being encrypted. Encrypted keys will be decrypted with
     * options.passphrase. Multiple keys using different algorithms can be
     * provided either as an array of unencrypted key strings or buffers,
     * or an array of objects in the form `{pem: <string|buffer>[,passphrase: <string>]}`.
     * The object form can only occur in an array.object.passphrase is optional.
     * Encrypted keys will be decrypted with object.passphrase if provided, or options.passphrase if it is not.
     */
    key?: string | Buffer | Array<Buffer | KeyObject> | undefined;
    /**
     * Shared passphrase used for a single private key and/or a PFX.
     */
    passphrase?: string | undefined;
    /**
     * PFX or PKCS12 encoded private key and certificate chain. pfx is an
     * alternative to providing key and cert individually. PFX is usually
     * encrypted, if it is, passphrase will be used to decrypt it. Multiple
     * PFX can be provided either as an array of unencrypted PFX buffers,
     * or an array of objects in the form `{buf: <string|buffer>[,passphrase: <string>]}`.
     * The object form can only occur in an array.object.passphrase is optional.
     * Encrypted PFX will be decrypted with object.passphrase if provided, or options.passphrase if it is not.
     */
    pfx?: string | Buffer | Array<string | Buffer | PxfObject> | undefined;
}

/**
 * Represents a credential capable of providing an authentication token.
 */
export declare interface TokenCredential {
    /**
     * Gets the token provided by this credential.
     *
     * This method is called automatically by Azure SDK client libraries. You may call this method
     * directly, but you must also handle token caching and token refreshing.
     *
     * @param scopes - The list of scopes for which the token will have access.
     * @param options - The options used to configure any requests this
     *                TokenCredential implementation might make.
     */
    getToken(scopes: string | string[], options?: GetTokenOptions): Promise<AccessToken | null>;
}

/**
 * Represents a client that can integrate with the currently configured {@link Instrumenter}.
 *
 * Create an instance using {@link createTracingClient}.
 */
export declare interface TracingClient {
    /**
     * Wraps a callback in a tracing span, calls the callback, and closes the span.
     *
     * This is the primary interface for using Tracing and will handle error recording as well as setting the status on the span.
     *
     * Both synchronous and asynchronous functions will be awaited in order to reflect the result of the callback on the span.
     *
     * Example:
     *
     * ```ts
     * const myOperationResult = await tracingClient.withSpan("myClassName.myOperationName", options, (updatedOptions) => myOperation(updatedOptions));
     * ```
     * @param name - The name of the span. By convention this should be `${className}.${methodName}`.
     * @param operationOptions - The original options passed to the method. The callback will receive these options with the newly created {@link TracingContext}.
     * @param callback - The callback to be invoked with the updated options and newly created {@link TracingSpan}.
     */
    withSpan<Options extends {
        tracingOptions?: OperationTracingOptions;
    }, Callback extends (updatedOptions: Options, span: Omit<TracingSpan, "end">) => ReturnType<Callback>>(name: string, operationOptions: Options, callback: Callback, spanOptions?: TracingSpanOptions): Promise<Resolved<ReturnType<Callback>>>;
    /**
     * Starts a given span but does not set it as the active span.
     *
     * You must end the span using {@link TracingSpan.end}.
     *
     * Most of the time you will want to use {@link withSpan} instead.
     *
     * @param name - The name of the span. By convention this should be `${className}.${methodName}`.
     * @param operationOptions - The original operation options.
     * @param spanOptions - The options to use when creating the span.
     *
     * @returns A {@link TracingSpan} and the updated operation options.
     */
    startSpan<Options extends {
        tracingOptions?: OperationTracingOptions;
    }>(name: string, operationOptions?: Options, spanOptions?: TracingSpanOptions): {
        span: TracingSpan;
        updatedOptions: OptionsWithTracingContext<Options>;
    };
    /**
     * Wraps a callback with an active context and calls the callback.
     * Depending on the implementation, this may set the globally available active context.
     *
     * Useful when you want to leave the boundaries of the SDK (make a request or callback to user code) and are unable to use the {@link withSpan} API.
     *
     * @param context - The {@link TracingContext} to use as the active context in the scope of the callback.
     * @param callback - The callback to be invoked with the given context set as the globally active context.
     * @param callbackArgs - The callback arguments.
     */
    withContext<CallbackArgs extends unknown[], Callback extends (...args: CallbackArgs) => ReturnType<Callback>>(context: TracingContext, callback: Callback, ...callbackArgs: CallbackArgs): ReturnType<Callback>;
    /**
     * Parses a traceparent header value into a {@link TracingSpanContext}.
     *
     * @param traceparentHeader - The traceparent header to parse.
     * @returns An implementation-specific identifier for the span.
     */
    parseTraceparentHeader(traceparentHeader: string): TracingContext | undefined;
    /**
     * Creates a set of request headers to propagate tracing information to a backend.
     *
     * @param tracingContext - The context containing the span to propagate.
     * @returns The set of headers to add to a request.
     */
    createRequestHeaders(tracingContext?: TracingContext): Record<string, string>;
}

/**
 * Options that can be passed to {@link createTracingClient}
 */
export declare interface TracingClientOptions {
    /** The value of the az.namespace tracing attribute on newly created spans. */
    namespace: string;
    /** The name of the package invoking this trace. */
    packageName: string;
    /** An optional version of the package invoking this trace. */
    packageVersion?: string;
}

/** An immutable context bag of tracing values for the current operation. */
export declare interface TracingContext {
    /**
     * Sets a given object on a context.
     * @param key - The key of the given context value.
     * @param value - The value to set on the context.
     *
     * @returns - A new context with the given value set.
     */
    setValue(key: symbol, value: unknown): TracingContext;
    /**
     * Gets an object from the context if it exists.
     * @param key - The key of the given context value.
     *
     * @returns - The value of the given context value if it exists, otherwise `undefined`.
     */
    getValue(key: symbol): unknown;
    /**
     * Deletes an object from the context if it exists.
     * @param key - The key of the given context value to delete.
     */
    deleteValue(key: symbol): TracingContext;
}

/**
 * A simple policy to create OpenTelemetry Spans for each request made by the pipeline
 * that has SpanOptions with a parent.
 * Requests made without a parent Span will not be recorded.
 * @param options - Options to configure the telemetry logged by the tracing policy.
 */
export declare function tracingPolicy(options?: TracingPolicyOptions): PipelinePolicy;

/**
 * The programmatic identifier of the tracingPolicy.
 */
export declare const tracingPolicyName = "tracingPolicy";

/**
 * Options to configure the tracing policy.
 */
export declare interface TracingPolicyOptions {
    /**
     * String prefix to add to the user agent logged as metadata
     * on the generated Span.
     * Defaults to an empty string.
     */
    userAgentPrefix?: string;
    /**
     * Query string names whose values will be logged when logging is enabled. By default no
     * query string values are logged.
     */
    additionalAllowedQueryParameters?: string[];
}

/**
 * Represents an implementation agnostic tracing span.
 */
export declare interface TracingSpan {
    /**
     * Sets the status of the span. When an error is provided, it will be recorded on the span as well.
     *
     * @param status - The {@link SpanStatus} to set on the span.
     */
    setStatus(status: SpanStatus): void;
    /**
     * Sets a given attribute on a span.
     *
     * @param name - The attribute's name.
     * @param value - The attribute's value to set. May be any non-nullish value.
     */
    setAttribute(name: string, value: unknown): void;
    /**
     * Ends the span.
     */
    end(): void;
    /**
     * Records an exception on a {@link TracingSpan} without modifying its status.
     *
     * When recording an unhandled exception that should fail the span, please use {@link TracingSpan.setStatus} instead.
     *
     * @param exception - The exception to record on the span.
     *
     */
    recordException(exception: Error | string): void;
    /**
     * Returns true if this {@link TracingSpan} is recording information.
     *
     * Depending on the span implementation, this may return false if the span is not being sampled.
     */
    isRecording(): boolean;
}

/** The kind of span. */
export declare type TracingSpanKind = "client" | "server" | "producer" | "consumer" | "internal";

/** A pointer from the current {@link TracingSpan} to another span in the same or a different trace. */
export declare interface TracingSpanLink {
    /** The {@link TracingContext} containing the span context to link to. */
    tracingContext: TracingContext;
    /** A set of attributes on the link. */
    attributes?: {
        [key: string]: unknown;
    };
}

/** Options used to configure the newly created span. */
export declare interface TracingSpanOptions {
    /** The kind of span. Implementations should default this to "client". */
    spanKind?: TracingSpanKind;
    /** A collection of {@link TracingSpanLink} to link to this span. */
    spanLinks?: TracingSpanLink[];
    /** Initial set of attributes to set on a span. */
    spanAttributes?: {
        [key: string]: unknown;
    };
}

/**
 * Fired in response to upload or download progress.
 */
export declare type TransferProgressEvent = {
    /**
     * The number of bytes loaded so far.
     */
    loadedBytes: number;
};

/**
 * An TypeSpecRuntimeClientLogger is a function that can log to an appropriate severity level.
 */
export declare type TypeSpecRuntimeClientLogger = Debugger;

/**
 * The TypeSpecRuntimeLogger provides a mechanism for overriding where logs are output to.
 * By default, logs are sent to stderr.
 * Override the `log` method to redirect logs to another location.
 */
export declare const TypeSpecRuntimeLogger: TypeSpecRuntimeClientLogger;

/**
 * Defines the methods available on the SDK-facing logger.
 */
export declare interface TypeSpecRuntimeLogger {
    /**
     * Used for failures the program is unlikely to recover from,
     * such as Out of Memory.
     */
    error: Debugger;
    /**
     * Used when a function fails to perform its intended task.
     * Usually this means the function will throw an exception.
     * Not used for self-healing events (e.g. automatic retry)
     */
    warning: Debugger;
    /**
     * Used when a function operates normally.
     */
    info: Debugger;
    /**
     * Used for detailed troubleshooting scenarios. This is
     * intended for use by developers / system administrators
     * for diagnosing specific failures.
     */
    verbose: Debugger;
}

/**
 * The log levels supported by the logger.
 * The log levels in order of most verbose to least verbose are:
 * - verbose
 * - info
 * - warning
 * - error
 */
export declare type TypeSpecRuntimeLogLevel = "verbose" | "info" | "warning" | "error";

/**
 * The helper that transforms bytes with specific character encoding into string
 * @param bytes - the uint8array bytes
 * @param format - the format we use to encode the byte
 * @returns a string of the encoded string
 */
export declare function uint8ArrayToString(bytes: Uint8Array, format: EncodingType): string;

/**
 * A generic shape for a plain JS object.
 */
export declare type UnknownObject = {
    [s: string]: unknown;
};

/**
 * Extends the SDK with support for a given instrumenter implementation.
 *
 * @param instrumenter - The instrumenter implementation to use.
 */
export declare function useInstrumenter(instrumenter: Instrumenter): void;

/**
 * A policy that sets the User-Agent header (or equivalent) to reflect
 * the library version.
 * @param options - Options to customize the user agent value.
 */
export declare function userAgentPolicy(options?: UserAgentPolicyOptions): PipelinePolicy;

/**
 * The programmatic identifier of the userAgentPolicy.
 */
export declare const userAgentPolicyName = "userAgentPolicy";

/**
 * Options for adding user agent details to outgoing requests.
 */
export declare interface UserAgentPolicyOptions {
    /**
     * String prefix to add to the user agent for outgoing requests.
     * Defaults to an empty string.
     */
    userAgentPrefix?: string;
}

export { }
